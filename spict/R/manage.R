# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015-2016  Martin W. Pedersen, mawp@dtu.dk, wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' @name manage
#' @title Calculate predictions under 8 default management scenarios
#'
#' @details The 8 default scenarios are:
#'
#' \itemize{
#'   \item{"1"}{"currentCatch": Keep the catch of the current year (i.e. the last observed catch).}
#'   \item{"2"}{"currentF":  Keep the F of the current year.}
#'   \item{"3"}{"Fmsy": Fish at Fmsy i.e. F=Fmsy.}
#'   \item{"4"}{"noF": No fishing, reduce to 1\% of current F.}
#'   \item{"5"}{"redF25": Reduce F by X\%. Default X = 25.}
#'   \item{"6"}{"incrF25": Increase F by X\%. Default X = 25.}
#'   \item{"7"}{"msyHockeyStick": Use ICES MSY hockey-stick advice rule (ICES, 2017).}
#'   \item{"8"}{"ices": Use ICES MSY 35th hockey-stick advice rule (ICES, 2019).}}
#'
#' Scenario 7 implements the ICES MSY advice rule for stocks that are assessed
#' using spict (ICES 2017). MSY B_{trigger} is set equal to B_{MSY} / 2. Then
#' fishing mortality in the short forecast is calculated as:
#'
#' F(y+1) = F(y) * min{ 1, median[B(y+1) / MSY B_{trigger}] } /
#' median[F(y)/F_{MSY}
#'
#' Scenario 8 is similar to scenario 7, but includes assessment uncertainty in
#' the predictions by using the 35th percentile of the distributions of the
#' predicted catch, B/B_{MSY} and F/F_{MSY}.
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarios Vector of integers specifying which scenarios to run or
#'     'all' to run all scenarios. Default: 'all'.
#' @param maninterval Year that management should be initiated.
#' @param maneval when to evaluate management
#' @param verbose more output?
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @return List containing results of management calculations.
#' @references ICES. 2017. Report of the Workshop on the Development of the ICES
#'     approach to providing MSY advice for category 3 and 4 stocks
#'     (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/ACOM:47.
#'     53 pp.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' repman <- manage(rep)
#' sumspict.manage(repman) # To print projections
#'
#' @export
manage <- function(rep, scenarios = 'all',
                   maninterval = NULL,
                   maneval = NULL,
                   verbose = TRUE,
                   dbg = 0){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    ## check if management time within model time
    repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)
    repout <- repin

    if (any(scenarios == 'all')){
        scenarios <- 1:8
    }

    timelastobs <- repin$inp$time[repin$inp$indlastobs]
    if(!repin$inp$timepredc < timelastobs){
        ## mange overwrites all scenarios
        repout$man <- NULL
        repout$manbase <- NULL

        if (1 %in% scenarios){
            # 1. Keep current catch
            repout <- man.scenario(repout, scenarioTitle = "currentCatch", cfac = 1.0, csdfac = 1.0)
        }
        if (2 %in% scenarios){
            # 2. Keep current F
            repout <- man.scenario(repout, scenarioTitle = "currentF", ffac = 1.0)
        }
        if (3 %in% scenarios){
            # 3. Fish at Fmsy
            repout <- man.scenario(repout, scenarioTitle = "Fmsy",)
        }
        if (4 %in% scenarios){
            # 4. No fishing, reduce to 0.1% of last F
            repout <- man.scenario(repout, scenarioTitle = "noF", ffac = 0.001)
        }
        if (5 %in% scenarios){
            # 5. Reduce F by 25%
            repout <- man.scenario(repout, scenarioTitle = "redF25", ffac = 0.75)
        }
        if (6 %in% scenarios){
            # 6. Increase F by 25%
            repout <- man.scenario(repout, scenarioTitle = "incrF25", ffac = 1.25)
        }
        if (7 %in% scenarios){
            # 7. Fish at Fmsy with hockey stick rule
            #    (F is equal to Fmsy if B > MSYBtrigger. F is reduced linearly to zero if B < MSYBtrigger)
            repout <- man.scenario(repout, scenarioTitle = "msyHockeyStick", breakpointB = 0.5)
        }
        if (8 %in% scenarios){
            # 8. Fish at Fmsy with hockey stick rule plus 35th percentile
            #    (same as 7. with 35th percentile of the catch, BBmsy and FFmsy distributions.)
            repout <- man.scenario(repout, scenarioTitle = "ices", breakpointB = 0.5,
                                        fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35))
        }
        attr(repout$man, "scenarios") <- scenarios
    }else{
        stop("Could not do management calculations because prediction horizon is too short. Increase the management interval 'maninterval'.")
    }
    return(repout)
}


#' @name sumspict.manage
#'
#' @title Print management summary.
#'
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param timeline (default: FALSE)
#' @param verbose Print more details on observed and predicted time intervals.
#'
#' @return Data frame containing management summary.
#'
#' @export
sumspict.manage <- function(rep, include.EBinf=FALSE, include.unc=TRUE, timeline = TRUE, verbose=TRUE){
    repin <- rep
    if(!'man' %in% names(repin)){
        stop("Management calculations not found, 'run manage()' or 'man.scenario()' to include them.")
    }else{
        repman <- repin$man
        rep <- repin$manbase
        # Calculate percent difference.
        get.pdelta <- function(rep, repman, indstart, indnext, parname='logB'){
            val <- get.par(parname, rep, exp=TRUE)[indstart, 2]
            val1 <- get.par(parname, repman, exp=TRUE)[indnext, 2]
            return(round((val1 - val)/val*100, 1))
        }
        indstart <- which(rep$inp$time == min(rep$inp$maninterval))
        #indstart <- rep$inp$indpred[1]-1 # Current time (last time interval of last year)
        #curtime <- rep$inp$time[indstart+1]
        curtime <- min(rep$inp$maninterval)  ## current time as start of man period
        indnext <- which(rep$inp$time == max(rep$inp$maninterval))
        Cn <- paste0('C')
        Bn <- paste0('B')
        Fn <- paste0('F')
        get.cn <- function(nn){
            nc <- nchar(nn)
            tl <- 7 # Total length
            # Add spaces
            #pad <- ifelse(include.unc, paste0(rep(' ', max(0, tl-nc)), collapse=''), '')
            pad <- ''
            return(c(paste0(nn, '.lo'), paste0(pad, nn), paste0(nn, '.hi')))
        }
        BBn <- paste0('BqBmsy') # Should use / instead of q, but / is not accepted in varnames
        FFn <- paste0('FqFmsy')
        EBinfBn <- paste0('EBinfqBmsy')
        scenarios <- names(repman)
        if(any(scenarios == "")){
            scenarios[which(scenarios == "")] <- paste0("customScenario_", seq(length(which(scenarios == ""))))
        }
        names(repman) <- scenarios
        nsc <- length( scenarios )
        Cnextyear <- matrix(0, nsc, 3)
        colnames(Cnextyear) <- get.cn(Cn)
        Bnextyear <- matrix(0, nsc, 3)
        colnames(Bnextyear) <- get.cn(Bn)
        Fnextyear <- matrix(0, nsc, 3)
        colnames(Fnextyear) <- get.cn(Fn)
        BBnextyear <- matrix(0, nsc, 3)
        colnames(BBnextyear) <- get.cn(BBn)
        FFnextyear <- matrix(0, nsc, 3)
        colnames(FFnextyear) <- get.cn(FFn)
        perc.dB <- numeric(nsc)
        perc.dF <- numeric(nsc)
        EBinf <- numeric(nsc)
        for(i in 1:nsc){
            rp <- repman[[ scenarios[i] ]]
            EBinf[i] <- get.EBinf(rp)
            perc.dB[i] <- get.pdelta(rep, rp, indstart, indnext, parname='logB')
            perc.dF[i] <- get.pdelta(rep, rp, indstart, indnext, parname='logF')
            indnextC <- which((rp$inp$timeCpred + rp$inp$dtcp) == max(rep$inp$maninterval))
            Cnextyear[i, ] <- round(get.par('logCpred', rp, exp=TRUE)[indnextC, 1:3], 1)
            Bnextyear[i, ] <- round(get.par('logB', rp, exp=TRUE)[indnext, 1:3], 1)
            Fnextyear[i, ] <- round(get.par('logF', rp, exp=TRUE)[indnext, 1:3], 3)
            BBnextyear[i, ] <- round(get.par('logBBmsy', rp, exp=TRUE)[indnext, 1:3], 3)
            FFnextyear[i, ] <- round(get.par('logFFmsy', rp, exp=TRUE)[indnext, 1:3], 3)
        }
        indnextCrep <- which((rep$inp$timeCpred+rep$inp$dtcp) == max(rep$inp$maninterval))
        FBtime <- fd(max(rep$inp$maninterval))
        Ctime1 <- fd(rep$inp$timeCpred[indnextCrep])
        Ctime2 <- fd(rep$inp$timeCpred[indnextCrep]+rep$inp$dtcp[indnextCrep])
        if (!verbose){
            Cn <- paste0('C', Ctime1)
            Bn <- paste0('B', FBtime)
            Fn <- paste0('F', FBtime)
        }
        # Data frame with predictions
        df <- cbind(Cnextyear[, 2], Bnextyear[, 2], Fnextyear[, 2], BBnextyear[, 2],
                    FFnextyear[, 2], perc.dB, perc.dF)
        colnames(df)[1:5] <- c(Cn, Bn, Fn, BBn, FFn)
        qinds <- grep('q', colnames(df))
        colnames(df)[qinds] <- sub('q', '/', colnames(df)[qinds]) # Replace q with /
        # Data frame with uncertainties of absolute predictions
        inds <- c(1, 3)
        dfabs <- cbind(Cnextyear[, inds,drop=FALSE], Bnextyear[, inds,drop=FALSE], Fnextyear[, inds,drop=FALSE])
        colnames(dfabs) <- c(colnames(Cnextyear)[inds], colnames(Bnextyear)[inds],
                             colnames(Fnextyear)[inds])
        # Data frame with uncertainties of relateive predictions
        dfrel <- cbind(BBnextyear[, inds,drop=FALSE], FFnextyear[, inds,drop=FALSE])
        colnames(dfrel) <- c(colnames(BBnextyear)[inds], colnames(FFnextyear)[inds])
        qinds <- grep('q', colnames(dfrel))
        colnames(dfrel)[qinds] <- sub('q', '/', colnames(dfrel)[qinds]) # Replace q with /
        # Set row names
        rn <- suppressMessages(unlist(
            plyr::revalue(scenarios, replace = list("currentCatch" = 'Keep current catch',
                                                    "currentF" = 'Keep current F',
                                                    "Fmsy" = 'Fish at Fmsy',
                                                    "noF" = 'No fishing',
                                                    "redF25" = 'Reduce F 25%',
                                                    "incrF25" = 'Increase F 25%',
                                                    "msyHockeyStick" = 'MSY hockey-stick rule',
                                                    "ices" = 'ICES advice rule'))))
        rn <- paste0(paste0(seq(length(rn)),". "),rn, "")
        rownames(df) <- rn
        rownames(dfrel) <- rn
        rownames(dfabs) <- rn
        #cat('Management summary\n')
        timerangeI <- range(unlist(rep$inp$timeI))
        timerangeC <- range(rep$inp$timeC)
        lastcatchseen <- tail(rep$inp$timeC+rep$inp$dtc, 1)
        # Start printing stuff
        if (verbose){ # Time interval information
            if(!timeline){
                cat(paste0('Observed interval, index:  ',
                           fd(timerangeI[1]),
                           ' - ',
                           fd(timerangeI[2]),
                           '\n'))
                cat(paste0('Observed interval, catch:  ',
                           fd(timerangeC[1]),
                           ' - ',
                           fd(lastcatchseen),
                           '\n\n'))
                cat(paste0('Fishing mortality (F) prediction: ',
                           FBtime, '\n'))
                cat(paste0('Biomass (B) prediction:           ',
                           FBtime, '\n'))
                cat(paste0('Catch (C) prediction interval:    ',
                           Ctime1,
                           ' - ',
                           Ctime2,
                           '\n\n'))
                if (rep$inp$catchunit != ''){
                    cat(paste('Catch/biomass unit:', rep$inp$catchunit, '\n\n'))
                }
            }else{
                print.man.timeline(repin$inp)
                cat('\n')
            }
            cat('Predictions\n')
        }
        print(df)
        if (include.unc){
            cat('\n95% CIs of absolute predictions\n')
            print(dfabs)
            cat('\n95% CIs of relative predictions\n')
            print(dfrel)
        }
        invisible(df)
    }
}


#' @name mansummary
#'
#' @title Print management summary.
#'
#' @param repin A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param ypred Show results for ypred years from manstart.
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param verbose Print more details on observed and predicted time intervals.
#'
#' @aliases sumspict.manage
#'
#' @return Data frame containing management summary.
#' @export
mansummary <- function(repin, ypred=1, include.EBinf=FALSE, include.unc=TRUE, verbose=TRUE){
    sumspict.manage(rep = repin, ypred = ypred,
                    include.EBinf=include.EBinf, include.unc=include.unc, verbose=verbose)
}


#' @name check.man.time
#' @title Checks and corrects management time to be within model time
#'
#' @param x Either an input list from \code{check.inp} or a result report as
#'     generated by running \code{fit.spict}.
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: maninterval = c(2020.25,2021.25). Default =
#'     NULL.
#' @param maneval Time at which to evaluate model states. Example: maneval =
#'     2021.25. Default = NULL.
#' @param verbose logical; print informative text (default: TRUE)
#'
#' @return Updated input list or fitted spict object dependent on type of input.
#'
#' @export
check.man.time <- function(x, maninterval = NULL, maneval = NULL, verbose = TRUE){

    if(!inherits(x, "spictcls")){
        x <- try(check.inp(x, verbose = FALSE), silent=TRUE)
        if(inherits(x, "try-error")){
            stop("Provided object 'x' needs to be an input list or a fitted spict object!")
        }
    }

    isrep <- ifelse(inherits(x, "spictcls") && "opt" %in% names(x), 1, 0)

    if(isrep){
        repin <- x
        inpin <- x$inp
    }else{
        repin <- list()
        inpin <- x
    }

    ## update man args
    if(!is.null(maninterval)) inpin$maninterval <- maninterval
    if(!is.null(maneval)) inpin$maneval <- maneval

    ## affected, but overwritten by check.inp:
    ## indpred, indCpred, ns, time, dt, seasons, seasonindex, seasonindex2, ir, isdf, ic, nc, nobsCp, dtcp, timeCpred

    ## affected:
    varNull <- c("logmcovariatein","ffacvec","fconvec", "MSYregime")
    varIniNull <- c("logF","logB","logmre","logu")

    ## adjust management interval if before last catch obs
    maxtimeC <- max(inpin$timeC + inpin$dtc)
    minint <- min(inpin$maninterval)
    maxint <- max(inpin$maninterval)

    if(minint < maxtimeC){
        manintstart <- maxtimeC
        manintend <- maxint
        manintend <- ifelse(manintend > manintstart, manintend, manintstart + (maxint-minint))
        warning("The specified management interval [",
                inpin$maninterval[1],",",inpin$maninterval[2],
                "] must start at or after the last catch observation interval: ",
                maxtimeC,"! The management interval [",
                manintstart,",",manintend,"] is used instead.")
        inpin$maninterval <- c(manintstart, manintend)
    }
    repin$inp <- inpin

    ## extend model time if management times not included
    if(max(inpin$maninterval, inpin$maneval) > max(inpin$time)){
        ## 1. correcting inp list
        ## overwrite time vectors with wrong lengths
        if(verbose) warning(c("Following variables in 'inp' are overwritten: ",
                              paste0(c(varNull,paste0("ini$",varIniNull)),collapse=", ")))
        inpout <- inpin
        for(i in varNull) inpout[i] <- NULL
        for(i in varIniNull) inpout$ini[i] <- NULL
        inpout <- check.inp(inpout, verbose = FALSE)
        ## restore management
        inpout <- make.ffacvec(inpout, inpin$ffacvec[which(inpout$time == inpout$maninterval[1])])
        inpout <- make.fconvec(inpout, inpin$fconvec[which(inpout$time == inpout$maninterval[1])])
        ## restore prod regimes
        dtdiff <- length(inpout$MSYregime) - length(inpin$MSYregime)
        rlein <- rle(inpin$ir)
        ls <- length(rlein$lengths)
        rleout <- rlein
        rleout$lengths[ls] <- rleout$lengths[ls] + dtdiff
        inpout$ir <- inverse.rle(rleout)
        inpout$MSYregime <- as.factor(inpout$ir)
        inpout$noms <- inpin$noms
        ## 2. correcting rep list
        if(isrep){
            xout <- retape.spict(repin, inpout)
        }else{
            xout <- inpout
        }
    }else{
        if(isrep){
            xout <- repin
        }else{
            xout <- inpin
        }
    }
    if(verbose) print.man.timeline(inpin, verbose = FALSE)
    return(xout)
}

#' @name check.catchList
#' @title Check catch list
#' @param catchList list obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided)
#' @param scenarioTitle title of scenario
#' @return Checked catchList
check.catchList <- function(catchList, sdfac = 1){
    if(!"obsC" %in% names(catchList)) stop("Element 'obsC' is missing.")
    if(!"timeC" %in% names(catchList)) stop("Element 'timeC' is missing.")
    if(!"dtc" %in% names(catchList)) stop("Element 'dtc' is missing.")

    if(length(catchList$obsC) != length(catchList$timeC)) stop("The length of the elements of the catchList have to equal.")
    if(length(catchList$obsC) != length(catchList$dtc)) stop("The length of the elements of the catchList have to equal.")

    if(!"stdevfacC" %in% names(catchList))
        catchList$stdevfacC <- rep(sdfac,length(catchList$obsC))

    return(catchList)
}


#' @name man.scenario
#' @title Define management scenario
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarioTitle title of scenario
#' @param fractiles List defining the fractiles of the 3 distributions of
#'     "catch", "bbmsy", and "ffmsy" (see details for more information). By
#'     default (0.5) median is used for all 3 quantities.
#' @param breakpointBBmsy Breakpoint in terms of \eqn{B/B_{MSY}} for the
#'     hockey-stick HCR (see details for more information). By default (0) no
#'     breakpoint is assumed.
#' @param safeguardB List defining an optional precautionary buffer by means of a
#'     biomass reference level relative to \eqn{B/B_{MSY}} ("limitB"; default =
#'     0, i.e. deactivating the PA buffer) and the risk aversion probability
#'     ("prob"; default = 0.95). For more information see details.
#' @param catchIntermediateYear Catch during assessment year (corresponding to argument
#'     \code{catch} in \code{\link{take.c}}), e.g. last year's TAC (default:
#'     \code{NULL}; see details for more information).
#' @param catchIntermediateYearSDFac Factor for the multiplication of the standard deveiation of the
#'     catch during the assessment year (\code{stdevfacC}; default = 1; see
#'     \code{\link{take.c}}).
#' @param getFit Logical; if \code{TRUE} the function returns the fitted
#'     'spictcls' object with respective HCR (\code{FALSE} by default).
#'
#' @details The combination of the arguments in the "fractiles",
#'     "breakpointB", and "safeguardB" allow defining a number of different
#'     harvest control rules (HCRs):
#'\itemize{
#' \item{Fishing at F_{MSY}: if \code{breakpointB == 0} and
#'     \code{safeguardB$limitB == 0}.}
#' \item{MSY hockey-stick rule: Fishing at F_{MSY} above a certain biomass reference
#'     level (here defined as a fraction of B_{MSY} with \code{breakpointB}).
#'     Below the reference level, fishing is reduced linearly to 0 as suggested in
#'     ICES (2017).}
#' \item{MSY (hockey-stick) rule with additional precautionary buffer: As long
#'     as the probability of the predicted biomass relative to a reference
#'     biomass level (e.g. 0.3 B_{MSY}, defined by \code{safeguardB$limitB}) is smaller or
#'     equal to a specified risk aversion probability (e.g. 95%, defined by
#'     \code{safeguardB$prob}), fishing at F_{MSY} or following the hockey-stick rule
#'     (if \code{breakpoint != 0}), otherwise reduce fishing mortality to meet
#'     specified risk aversion probability (\code{safeguardB$prob}) as introduced in
#'     ICES (2018).}
#' \item{By ICES (2019) recommended MSY hockey-stick rule with 35th percentiles:
#'     Fishing at 35th percentile of F_{MSY} above the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}} (\code{breakpointB = 0.5}) and 35th percentile of
#'     linearly reduced F_{MSY} below the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}}. TAC corresponds to 35th percentile of predicted catch.
#'     Rule is applied with \code{fractiles = list(catch=0.35, bbmsy=0.35,
#'     ffmsy=0.35)}, \code{breakpointB = 0.5}, and \code{safeguardB =
#'     list(limitB = 0, prob = 0.95)}.}}
#'
#' More information about the function arguments controlling the HCRs. The
#' arguments of the "fractiles" are:
#' \itemize{
#' \item{catch - Fractile of the predicted catch distribution. Default: 0.5.}
#' \item{bbmsy - Fractile of the \eqn{B/B_{MSY}} distribution. Default: 0.5.}
#' \item{ffmsy - Fractile of the \eqn{F/F_{MSY}} distribution. Default: 0.5.}}
#'
#' The argument "breakpointBBmsy" allows to define the MSY hockey-stick rule,
#' which reduces fishing linearly if the biomass is below specified reference
#' level as specified here relative to B_{MSY}. Theoretically, any value below 1
#' is meaningful, but ICES (2017 to 2019) recommend 50% of B_{MSY}
#' (\code{breakpointBBmsy = 0.5}).
#'
#'
#' The argument list "safeguardB" includes:
#' \itemize{
#' \item{bbmsy - Reference level for the evaluation of the predicted biomass
#'   defined as fraction of \eqn{B/B_{MSY}}. By default (\code{safeguardB$limitB == 0})
#'   the PA buffer is not used. Theoretically, any value smaller than 1 is
#'
#' meaningful, but an ICES recommended value would be 30% \code{safeguardB$limitB = 0.3}
#' (ICES, 2018).}
#' \item{prob - Risk aversion probability of the predicted biomass relative to
#'   specified reference level (\code{safeguardB$limitB}) for all rules with PA
#'   buffer (\code{safeguardB$limitB != 0}). Default: 0.95 as recommended by ICES
#'   (2018).}}
#'
#' NOTE: fractile for Fmsy is 1-f
#'
#' Dependent on the start of the management period (e.g. advice year), there
#' might be a time lag between the last observation and the start of the
#' management period. If this is the case, an assumption about the intermediate
#' time period (e.g. assessment year) has to be made. Either the fishing
#' mortality is extrapolated for the intermediate time period (\code{catchIntermediateYear
#' = NULL}; default), or the argument \code{catchIntermediateYear} can be used to set the
#' catch in that period. The argument \code{catchIntermediateYearSDFac} allows to adjust the standard
#' deviation of the catch in the intermediate time period.
#'
#' @return A list with the TAC and management relevant quantities; if
#'     \code{getFit} is \code{TRUE} the fitted object with the respective HCR is
#'     returned.
#'
#' @references
#' ICES. 2017. Report of the Workshop on the Development of the ICES
#' approach to providing MSY advice for category 3 and 4 stocks
#' (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/
#' ACOM:47. 53 pp.
#'
#' ICES. 2018. Report of the Eighth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE VIII), 8-12 October 2018, Lisbon,
#' Portugal. ICES CM 2018/ACOM:40. 172 pp.
#'
#' ICES 2019. Report of the Ninth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE IX), 30 September-4 October 2019,
#' Lisbon, Portugal.
#'
#' @export
#' @examples
#' rep <- fit.spict(pol$albacore)
#'
#' ## Fishing at Fmsy
#' get.TAC(rep)
#'
#' ## MSY hockey-stick rule
#' get.TAC(rep, breakpointB = 0.5)
#'
#' ## ICES (2019) recommended HCR
#' get.TAC(rep, fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35), breakpointB=0.5)
#'
man.scenario <- function(rep, scenarioTitle = "",
                         maninterval = NULL,
                         maneval = NULL,
                         ffac = NULL,   ## if NULL default fishing at fmsy
                         cfac = NULL,
                         csdfac = 1,
                         fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5),
                         breakpointB = 0,
                         safeguardB = list(limitB = 0, prob = 0.95),
                         catchIntermediateYear = NULL,
                         catchIntermediateYearSDFac = 1,
                         catchList = NULL,
                         getFit = TRUE,
                         verbose = TRUE,
                         dbg = 0){

    ## CHECKS
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    ## check if management time within model time
    repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)
    stopifnot(all(unlist(fractiles) <= 0.5 && unlist(fractiles) > 0))
    stopifnot(cfac >= 0)
    stopifnot(csdfac >= 0)
    stopifnot(ffac >= 0)
    stopifnot(breakpointB >= 0)
    if(is.numeric(ffac) && is.numeric(cfac))
        stop("Both 'ffac' and 'cfac' provided, please choose either or neither.")

    repout <- reppa <- repin
    inpin <- repin$inp

    ## FRACTILES
    if(!is.list(fractiles)) stop("Please provide 'fractiles' with the arguments: 'catch', 'bbmsy', and 'ffmsy'!")
    default_fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5)
    fList <- default_fractiles[which(!names(default_fractiles) %in% names(fractiles))]
    fList <- c(fList,fractiles)

    ## BIOMASS SAFEGUARD
    if(!is.list(safeguardB)) stop("Please provide 'safeguardB' with the arguments: 'limitB' and 'prob'!")
    default_safeguardB = list(limitB = 0, prob = 0.95)
    pList <- default_safeguardB[which(!names(default_safeguardB) %in% names(safeguardB))]
    pList <- c(pList,safeguardB)

    ## INTERMEDIATE YEAR
    inttime <- inpin$dtpredcinds[1] - min(inpin$indpred)
    if(inttime > 0 && !is.null(catchIntermediateYear) &&
       !is.na(catchIntermediateYear) && is.numeric(catchIntermediateYear)){
        inpt <- inpin
        dtcint <- (inpin$dtpredcinds[1] - min(inpin$indpred)) * inpin$dteuler
        if(verbose) writeLines(paste0("The intermediate time period is ",dtcint," year(s) long. The catch 'catchIntermediateYear' should be representative of that period.\n"))
        inpt$timeC <- c(inpt$timeC, inpin$time[min(inpin$indpred)])
        inpt$obsC <- c(inpt$obsC, catchIntermediateYear)
        inpt$stdevfacC <- c(inpt$stdevfacC, catchIntermediateYearSDFac)
        inpt$dtc <- c(inpt$dtc, dtcint)
        inpt <- check.inp(inpt, verbose = FALSE)
        repin <- retape.spict(repin, inpin, verbose = FALSE)
        inpin <- repin$inp
    }

    ## QUANTITIES
    fmanstart <- get.par('logFm', repin, exp=TRUE)[2]
    fmsy <- get.par('logFmsy', repin, exp=TRUE)[2]
    bmsy <- get.par('logBmsy', repin, exp=TRUE)[2]
    logFpFmsy <- get.par("logFpFmsynotS", repin)
    logBpBmsy <- get.par("logBpBmsy", repin)
    logFmFmsy <- get.par("logFmFmsynotS", repin)
    logBmBmsy <- get.par("logBmBmsy", repin)


    ## ADVICE RULES
    ## ---------------
    if(!is.numeric(cfac) || is.na(cfac)){
        if(!is.numeric(ffac) || is.na(ffac)){
            ## FFmsy component
            fi <- 1 - fList$ffmsy
            fmfmsyi <- exp(qnorm(fi, logFmFmsy[2], logFmFmsy[4]))
            fmfmsy5 <- exp(qnorm(0.5, logFmFmsy[2], logFmFmsy[4]))
            fred <- fmfmsy5 / fmfmsyi
            ## BBmsy component (hockey stick HCR)
            if(!is.na(breakpointB) && is.numeric(breakpointB) && breakpointB != 0){
                bmbmsyi <- 1/breakpointB * exp(qnorm(fList$bbmsy, logBmBmsy[2], logBmBmsy[4]))
                fred <- fred * min(1, bmbmsyi)
            }
            ## F reduction factor
            ffac <- (fred + 1e-8) * fmsy / fmanstart
            ## PA component
            if(!is.na(pList$limitB) && is.numeric(pList$limitB) && pList$limitB != 0){
                inppa <- make.ffacvec(inpin, ffac)
                inppa$reportmode <- 1
                reppa <- try(retape.spict(reppa, inppa), silent=TRUE)
                if(inherits(reppa,"try-error")){
                    warning("The fishing mortality multiplication factor 'ffac' could not be estimated with this management scenario due to an error when retaping the updated spict model. 'ffac' is set to 1, which assumes no change in the fishing mortality.")
                    ffac <- 1
                }else{
                    logBpBmsyPA <- get.par("logBpBmsy", reppa)
                    probi <- 1 - pList$prob
                    bpbmsyiPA <- exp(qnorm(probi, logBpBmsyPA[2], logBpBmsyPA[4]))
                    if((bpbmsyiPA - pList$limitB) < -1e-3){
                        ffac <- try(get.ffac(reppa, ref=pList$limitB,
                                             problevel=pList$prob,
                                             var="logBpBmsy",
                                             reportmode = 1), silent=TRUE)
                        if(inherits(ffac,"try-error")){
                            warning("The fishing mortality multiplication factor 'ffac' could not be estimated with this management scenario due to an error when optimising the risk aversion probability over F. 'ffac' is set to 1, which assumes no change in the fishing mortality.")
                            ffac <- 1
                        }

                    }
                }
            }
        }
        inpt <- make.ffacvec(inpin, ffac)
    }else{
        ## Fishing with provided catch
        inpt <- inpin
        if(is.null(catchList)){

            ## Default catch during maninterval preserving seasonality
            ## observation indices representative of the last full year
            indFullYear = (length(inpin$timeC) - (which(cumsum(rev(diff(inpin$timeC))) == 1)-1)) :
                length(inpin$timeC)
            timeLastC <- inpin$timeC[indFullYear]
            obsLastC <- inpin$obsC[indFullYear]
            dtc <- diff(inpin$timeC)
            dtcLastC <- c(dtc,dtc[length(dtc)])[indFullYear]
            mindtc <- min(dtcLastC)
            tmpTime <- inpin$timeCpred

            ## management indices
            manint <- inpin$maninterval
            manperiod <- max(manint) - min(manint)
            manperiodYears <- floor(manperiod)
            manperiodSpanYear <- floor(manint[2]) - floor(manint[1])
            maninds <- which(tmpTime >= min(inpin$maninterval))

            ## match man indices to obs indices
            potcatchTimes <- timeLastC ##unique(c(timeLastC, timeLastC + dtcLastC))
            potcatchTimeYear <- potcatchTimes %% min(floor(potcatchTimes))
            potcatchTimeYears <- rep(potcatchTimeYear,manperiodSpanYear+1) +
                rep(0:manperiodSpanYear,each = length(potcatchTimeYear))
            mantimes <- seq(potcatchTimeYears[which.min(abs(potcatchTimeYears-(manint[1] %% 1)))],
                            potcatchTimeYears[which.min(abs(potcatchTimeYears-(manint[2] %% 1 +
                                                                               manperiodSpanYear - mindtc)))],
                            by = mindtc)
            catchTimeYears <- potcatchTimeYears[potcatchTimeYears %in% mantimes]

            ## sum
            indi <- match((catchTimeYears %% 1), potcatchTimeYears)
            obsint <- range(c(timeLastC[indi],
                    timeLastC[indi] +
                    dtcLastC[indi]))
            manC <- sum(obsLastC[indi])
            shortlong <- ifelse(manperiod >= diff(range(obsint)), "shorter", "longer")

            if(verbose && manperiod != diff(range(obsint)))
                warning(paste0("The catch observations do not allow to set a representative default catch for the specified management interval [",manint[1],",",manint[2],"], the catch observations representative of the ",shortlong," interval [",obsint[1],",",obsint[2],"] are used. Use the argument 'catchList' to specify the catch for the management period or change the management period to correspond to a multiple of the catch observation intervals in the last year with catch observations."))

            ## default catchList
            inpt$timeC <- c(inpt$timeC, tmpTime[maninds])
            inpt$obsC <- c(inpt$obsC, rep(manC * cfac, length(maninds)))
            inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(maninds)))
            inpt$dtc <- c(inpt$dtc, rep(inpt$dtpredc, length(maninds)))
        } else {
            ## specified catchList
            check.catchList(catchList)
            inpt$timeC <- c(inpt$timeC, catchList$timeC)
            inpt$obsC <- c(inpt$obsC, catchList$obsC)
            if(is.null(catchList$stdevfacC)){
                inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(catchList$timeC)))
            }else{
                inpt$stdevfacC <- c(inpt$stdevfacC, catchList$stdevfacC)
            }
            inpt$dtc <- c(inpt$dtc, catchList$dtc)
        }
        inpt <- check.inp(inpt, verbose = FALSE)
    }

    if(getFit){
        ## retape spict
        repman <- retape.spict(repin, inpt, verbose = FALSE)
        repman$man <- NULL
        repman$manbase <- NULL
        ## check if man already in repin
        if(!"man" %in% names(repin)){
            repout$man <- list()
            repout$man[[1]] <- repman
            if(scenarioTitle == "") scenarioTitle <- "customScenario_1"
            names(repout$man)[1] <- scenarioTitle
            # Create an baseline F trajectory with constant F and store
            repout <- man.scenario(repout, scenarioTitle = "manbase", ffac = 1.0)
        }else{
            if(scenarioTitle == "manbase"){
                repout$manbase <- repman
            }else{
                if(scenarioTitle == ""){  ## set customScenario name with counter
                    custs <- strsplit(names(repin$man),"_")
                    custind <- unlist(lapply(custs, function(x) "customScenario" %in% x))
                    custcount <- min(1,ifelse(any(custind),
                                              max(as.numeric(unlist(lapply(custs[custind],
                                                                           function(x) x[[2]])))) + 1,1))
                    scenarioTitle <- paste0("customScenario_", custcount)
                }else{
                    taken <- scenarioTitle %in% names(repin$man)
                    if(taken){
                        repout$man[[which(taken)]] <- repman
                    }else{
                        nman <- length(repin$man) + 1
                        repout$man[[nman]] <- repman
                        names(repout$man)[nman] <- scenarioTitle
                    }
                }
            }
        }
        return(repout)
    }else{
        ## return tac only
        tac <- try(calc.tac(rep=repin, ffac=ffac, fractileCatch=fList$catch), silent=TRUE)
        if(is(tac,"try-error")) stop("TAC could not be estimated.")
        return(tac)
    }
}


#' @name probdev
#' @title Estimate deviation between targeted and realised probability of
#'     specified model variable hitting a specified reference level under given
#'     fishing mortality
#'
#' @param ffac Factor to multiply current fishing mortality by (default: 1)
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param var A variable of the spict model (default: "logBpBmsy").
#' @param ref Reference level relative to specified variable (default = 1)
#' @param problevel Probability level of the risk aversion (default = 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default = 1).
#' @param getFrac logical; return realised fraction of relative state (default =
#'     FALSE).
#' @param verbose logical; print realised fraction of relative state, fishing
#'     mortality factor, and deviation (default = FALSE).
#'
#' @return Returns deviation between targeted and realised probability of
#'     hitting specified reference levels under given fishing mortality
probdev <- function(ffac = 1, rep, var = "logBpBmsy", ref = 1,
                    problevel = 0.95, reportmode = 1, getFrac = FALSE,
                    verbose = FALSE){
    ## get F factor
    inpt <- make.ffacvec(rep$inp, ffac)
    inpt$reportmode <- reportmode
    rept <- retape.spict(rep, inpt)
    vart <- get.par(var,rept)
    ll <- qnorm(1 - problevel, vart[,2], vart[,4])
    dev <- (exp(ll) - ref)^2
    if(verbose)  cat("exp(ll): ",exp(ll),"ffac: ",ffac," dev: ",dev,"\n")
    if(getFrac) dev <- exp(ll)
    dev
}


#' @name get.ffac
#' @title Estimate fishing mortality factor minimising probability of specified
#'     model variable hitting a specified reference level under given fishing
#'     mortality
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param var A variable of the spict model (default: "logBpBmsy").
#' @param ref Reference level relative to specified variable (default = 1)
#' @param problevel Probability level of the risk aversion (default = 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default = 1).
#' @param verbose logical; print informative text (default = TRUE).
#'
#' @return Optimised Fishing mortality for P(Bp<Blim)
get.ffac <- function(rep, var = "logBpBmsy", ref = 1,
                     problevel=0.95, reportmode = 1,
                     verbose = TRUE){
    ## see if possible to hit target risk with zero F
    ffac0 <- probdev(ffac=1e-6, rep=rep, getFrac=TRUE, problevel=problevel,
                    var=var, ref = ref, reportmode=reportmode, verbose=FALSE)
    if(!is.finite(ffac0) || (ffac0 - ref) < -1e-3){
        if(verbose) cat("Not possible even with zero F\n")
        return(1e-6)
    }
    offac <- optimize(probdev, c(1e-6,5), tol=1e-2, rep=rep,
                      var=var, problevel=problevel,
                      ref=ref, reportmode=reportmode,
                      verbose=FALSE)
    offac$minimum
}


#' @name calc.tac
#' @title Calculate Total Allowable Catch (TAC)
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param ffac Factor to multiply current F by
#' @param fractileCatch The fractile of the catch distribution to be used for
#'     setting the TAC. Default (0.5) corresponds to the median.
#' @param exp Should tac be reported on natural scale? (default = TRUE)
#'
#' @return Total Allowable Catch (TAC)
#'
#' @export
calc.tac <- function(rep, ffac = NULL, fractileCatch = 0.5, exp = TRUE){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    if(!is.null(ffac) && is.numeric(ffac)){
        inpt <- make.ffacvec(rep$inp, ffac)
        inpt$reportmode <- 2
        rept <- retape.spict(rep, inpt)
    }else{
        rept <- rep
    }
    if(fractileCatch == 0.5){
        tac <- rept$obj$report(rept$obj$env$last.par.best)$Cp
    }else{
        logCp <- get.par('logCp', rept)
        tac <- exp(qnorm(fractileCatch, logCp[2], logCp[4]))
    }
    if(!exp) tac <- log(tac)
    return(tac)
}


#' @name man.select
#' @title Select management scenarios
#'
#' @param rep Result list from manage().
#' @param scenarios scenarios to select in preferred order
#'
#' @return rep wit selected management scenarios
#'
#' @export
man.select <- function(rep, scenarios = "all"){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    if(!"man" %in% names(rep)) stop("Apply manage() first.")
    if(all(is.numeric(scenarios))) scenarios <- names(rep$man)[scenarios]

    repout <- rep

    if(all(is.numeric(scenarios))){
        ind <- scenarios
    }else if(scenarios == "all"){
        ind <- seq(length(rep$man))
    }else{
        ind <- which(names(rep$man) %in% scenarios)
    }
    repout$man <- rep$man[ind]
    attr(repout$man, "scenarios") <- 1:length(repout$man)

    return(repout)
}


#' @name man.tac
#' @title Get the TAC for the management scenarios
#'
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param fractileCatch fractile
#' @param exp Should tac be reported on natural scale? (default = TRUE)
#'
#' @return rep wit selected management scenarios
#'
#' @export
man.tac <- function(rep, fractileCatch = 0.5, exp = TRUE){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("not spictcls object - use fit.spict first")
    if(!"man" %in% names(rep)) stop("Apply manage() or man.scenario() first.")

    ## function(x) x$obj$report(x$obj$env$last.par.best)$Cp
    tacs <- lapply(rep$man, calc.tac, ffac = NULL, fractileCatch = fractileCatch, exp = exp)

    return(tacs)
}


#' @name manbase.select
#' @title Change the management base scenario
#'
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param scenario New manbase scenario
#'
#' @return rep wit selected management scenario as the manbase scenario
#'
#' @export
manbase.select <- function(rep, scenario){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    if(!"man" %in% names(rep)) stop("Apply manage() or man.scenario() first.")
    if(length(scenario) > 1) stop("Please provide only one scenario as baseline scenario!")
    if(is.numeric(scenario)) scenario <- names(rep$man)[scenario]
    if(!scenario %in% names(rep$man)) stop(paste0("Scenario ",scenario, "not included in 'rep$man'."))

    repin <- rep
    repout <- repin$man[[scenario]]
    repout$manbase <-repin$man[[scenario]]
    repout$man <- repin$man

    return(repout)
}


#' @name print.man.timeline
#' @title Print a schematic to the console visualising the management timeline
#'
#' @param x Either an input list from \code{check.inp} or a result report as
#'     generated by running \code{fit.spict}.
#' @param verbose informative text
#'
#' @return Nothing
#'
#' @export
print.man.timeline <- function(x, verbose = TRUE){
    if(!inherits(x, "spictcls")){
        x <- try(check.inp(x, verbose = FALSE), silent=TRUE)
        if(inherits(x, "try-error")){
            stop("Provided object 'x' needs to be an input list or a fitted spict object!")
        }
    }
    if(inherits(x, "spictcls") && "opt" %in% names(x)){
        inp <- x$inp
    }else{
        inp <- x
    }
    inp <- check.inp(inp, verbose = verbose)
    timeC <- range(inp$timeC,inp$timeC + inp$dtc)
    timeM <- range(inp$maninterval)
    timeInt <- c(max(timeC), min(timeM))
    obstext <- c("      Observations",
                 paste0("      ",min(timeC)," - ",max(timeC)),
                 "|---------------------------|")
    inttext <- c("  Intermediate",
                 paste0("  ",min(timeInt)," - ",max(timeInt)),
                 "-----------------|")
    mantext <- c("  Management",
                 paste0("  ",min(timeM)," - ",max(timeM)),
                 "-----------------|")
    if(max(timeC) == min(timeM)){
        df <- cbind(obstext, mantext)
    }else{
        df <- cbind(obstext, inttext, mantext)
    }
    rownames(df) <- rep("",dim(df)[1])
    colnames(df) <- rep("",dim(df)[2])
    cat("SPiCT timeline:\n")
    print(df, quote=FALSE, row.names = FALSE)
}
