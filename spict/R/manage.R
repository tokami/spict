# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015-2016  Martin W. Pedersen, mawp@dtu.dk, wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' @name manage
#' @title Calculate predictions under 8 default management scenarios
#'
#' @details The 8 default scenarios are:
#'
#' \itemize{
#'   \item{"1"}{"currentCatch": Keep the catch of the current year (i.e. the last observed catch).}
#'   \item{"2"}{"currentF":  Keep the F of the current year.}
#'   \item{"3"}{"Fmsy": Fish at Fmsy i.e. F=Fmsy.}
#'   \item{"4"}{"noF": No fishing, reduce to 1\% of current F.}
#'   \item{"5"}{"redF25": Reduce F by X\%. Default X = 25.}
#'   \item{"6"}{"incrF25": Increase F by X\%. Default X = 25.}
#'   \item{"7"}{"msyHockeyStick": Use ICES MSY hockey-stick advice rule (ICES, 2017).}
#'   \item{"8"}{"ices": Use ICES MSY 35th hockey-stick advice rule (ICES, 2019).}}
#'
#' Scenario 7 implements the ICES MSY advice rule for stocks that are assessed
#' using spict (ICES 2017). MSY B_{trigger} is set equal to B_{MSY} / 2. Then
#' fishing mortality in the short forecast is calculated as:
#'
#' F(y+1) = F(y) * min{ 1, median[B(y+1) / MSY B_{trigger}] } /
#' median[F(y)/F_{MSY}
#'
#' Scenario 8 is similar to scenario 7, but includes assessment uncertainty in
#' the predictions by using the 35th percentile of the distributions of the
#' predicted catch, B/B_{MSY} and F/F_{MSY}.
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarios Vector of integers specifying which scenarios to run or
#'     'all' to run all scenarios. Default: 'all'.
#' @param maninterval Year that management should be initiated.
#' @param maneval when to evaluate management
#' @param verbose more output?
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @return List containing results of management calculations.
#' @references ICES. 2017. Report of the Workshop on the Development of the ICES
#'     approach to providing MSY advice for category 3 and 4 stocks
#'     (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/ACOM:47.
#'     53 pp.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' repman <- manage(rep)
#' sumspict.manage(repman) # To print projections
#'
#' @export
manage <- function(rep, scenarios = 'all',
                   maninterval = NULL,
                   maneval = NULL,
                   verbose = TRUE,
                   dbg = 0){
    if(!inherits(rep, "spictcls")) stop("rep needs to be a fitted spict object!")
    ## check if management time within model time
    repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = verbose)
    repout <- repin

    if (any(scenarios == 'all')){
        scenarios <- 1:8
    }

    timelastobs <- repin$inp$time[repin$inp$indlastobs]
    if(!repin$inp$timepredc < timelastobs){
        ## mange overwrites all scenarios
        repout$man <- NULL
        repout$manbase <- NULL

        if (1 %in% scenarios){
            # 1. Keep current catch
            repout <- man.scenario(repout, scenarioTitle = "currentCatch", cfac = 1.0, csdfac = 1.0)
        }
        if (2 %in% scenarios){
            # 2. Keep current F
            repout <- man.scenario(repout, scenarioTitle = "currentF", ffac = 1.0)
        }
        if (3 %in% scenarios){
            # 3. Fish at Fmsy
            repout <- man.scenario(repout, scenarioTitle = "Fmsy",)
        }
        if (4 %in% scenarios){
            # 4. No fishing, reduce to 0.1% of last F
            repout <- man.scenario(repout, scenarioTitle = "noF", ffac = 0.001)
        }
        if (5 %in% scenarios){
            # 5. Reduce F by 25%
            repout <- man.scenario(repout, scenarioTitle = "redF25", ffac = 0.75)
        }
        if (6 %in% scenarios){
            # 6. Increase F by 25%
            repout <- man.scenario(repout, scenarioTitle = "incrF25", ffac = 1.25)
        }
        if (7 %in% scenarios){
            # 7. Fish at Fmsy with hockey stick rule
            #    (F is equal to Fmsy if B > MSYBtrigger. F is reduced linearly to zero if B < MSYBtrigger)
            repout <- man.scenario(repout, scenarioTitle = "msyHockeyStick", breakpointB = 0.5)
        }
        if (8 %in% scenarios){
            # 8. Fish at Fmsy with hockey stick rule plus 35th percentile
            #    (same as 7. with 35th percentile of the catch, BBmsy and FFmsy distributions.)
            repout <- man.scenario(repout, scenarioTitle = "ices", breakpointB = 0.5,
                                        fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35))
        }
        attr(repout$man, "scenarios") <- scenarios
    }else{
        stop("Could not do management calculations because prediction horizon is too short. Increase the management interval 'maninterval'.")
    }
    return(repout)
}


#' @name sumspict.manage
#'
#' @title Print management summary.
#'
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param ypred Show results for ypred years from manstart.  ## BUG: more or less what maneval stands for
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param verbose Print more details on observed and predicted time intervals.
#'
#' @return Data frame containing management summary.
#'
#' @export
sumspict.manage <- function(rep, ypred=1, include.EBinf=FALSE, include.unc=TRUE, verbose=TRUE){
    if (!'man' %in% names(rep)){
        stop("Management calculations not found, 'run manage()' or 'man.scenario()' to include them.")
    } else {
        repman <- rep$man
        rep <- rep$manbase
        # Calculate percent difference.
        get.pdelta <- function(rep, repman, indstart, indnext, parname='logB'){
            val <- get.par(parname, rep, exp=TRUE)[indstart, 2]
            val1 <- get.par(parname, repman, exp=TRUE)[indnext, 2]
            return(round((val1 - val)/val*100, 1))
        }
        indstart <- which(rep$inp$time == min(rep$inp$maninterval))
        #indstart <- rep$inp$indpred[1]-1 # Current time (last time interval of last year)
        #curtime <- rep$inp$time[indstart+1]
        curtime <- min(rep$inp$maninterval)  ## current time as start of man period
        indnext <- which(rep$inp$time == curtime+ypred) # Current time + ypred
        if (length(indnext) == 1){
            Cn <- paste0('C')
            Bn <- paste0('B')
            Fn <- paste0('F')
            get.cn <- function(nn){
                nc <- nchar(nn)
                tl <- 7 # Total length
                # Add spaces
                #pad <- ifelse(include.unc, paste0(rep(' ', max(0, tl-nc)), collapse=''), '')
                pad <- ''
                return(c(paste0(nn, '.lo'), paste0(pad, nn), paste0(nn, '.hi')))
            }
            BBn <- paste0('BqBmsy') # Should use / instead of q, but / is not accepted in varnames
            FFn <- paste0('FqFmsy')
            EBinfBn <- paste0('EBinfqBmsy')
            scenarios <- names(repman)
            if(any(scenarios == "")){
                scenarios[which(scenarios == "")] <- paste0("customScenario_", seq(length(which(scenarios == ""))))
            }
            names(repman) <- scenarios
            nsc <- length( scenarios )
            Cnextyear <- matrix(0, nsc, 3)
            colnames(Cnextyear) <- get.cn(Cn)
            Bnextyear <- matrix(0, nsc, 3)
            colnames(Bnextyear) <- get.cn(Bn)
            Fnextyear <- matrix(0, nsc, 3)
            colnames(Fnextyear) <- get.cn(Fn)
            BBnextyear <- matrix(0, nsc, 3)
            colnames(BBnextyear) <- get.cn(BBn)
            FFnextyear <- matrix(0, nsc, 3)
            colnames(FFnextyear) <- get.cn(FFn)
            perc.dB <- numeric(nsc)
            perc.dF <- numeric(nsc)
            EBinf <- numeric(nsc)
            for(i in 1:nsc){
                rp <- repman[[ scenarios[i] ]]
                EBinf[i] <- get.EBinf(rp)
                perc.dB[i] <- get.pdelta(rep, rp, indstart, indnext, parname='logB')
                perc.dF[i] <- get.pdelta(rep, rp, indstart, indnext, parname='logF')
                indnextC <- which((rp$inp$timeCpred + rp$inp$dtcp) == curtime+ypred)
                Cnextyear[i, ] <- round(get.par('logCpred', rp, exp=TRUE)[indnextC, 1:3], 1)
                Bnextyear[i, ] <- round(get.par('logB', rp, exp=TRUE)[indnext, 1:3], 1)
                Fnextyear[i, ] <- round(get.par('logF', rp, exp=TRUE)[indnext, 1:3], 3)
                BBnextyear[i, ] <- round(get.par('logBBmsy', rp, exp=TRUE)[indnext, 1:3], 3)
                FFnextyear[i, ] <- round(get.par('logFFmsy', rp, exp=TRUE)[indnext, 1:3], 3)
            }
            indnextCrep <- which((rep$inp$timeCpred+rep$inp$dtcp) == curtime+ypred)
            FBtime <- fd(curtime+ypred)
            Ctime1 <- fd(rep$inp$timeCpred[indnextCrep])
            Ctime2 <- fd(rep$inp$timeCpred[indnextCrep]+rep$inp$dtcp[indnextCrep])
            if (!verbose){
                Cn <- paste0('C', Ctime1)
                Bn <- paste0('B', FBtime)
                Fn <- paste0('F', FBtime)
            }
            # Data frame with predictions
            df <- cbind(Cnextyear[, 2], Bnextyear[, 2], Fnextyear[, 2], BBnextyear[, 2],
                        FFnextyear[, 2], perc.dB, perc.dF)
            colnames(df)[1:5] <- c(Cn, Bn, Fn, BBn, FFn)
            qinds <- grep('q', colnames(df))
            colnames(df)[qinds] <- sub('q', '/', colnames(df)[qinds]) # Replace q with /
            # Data frame with uncertainties of absolute predictions
            inds <- c(1, 3)
            dfabs <- cbind(Cnextyear[, inds,drop=FALSE], Bnextyear[, inds,drop=FALSE], Fnextyear[, inds,drop=FALSE])
            colnames(dfabs) <- c(colnames(Cnextyear)[inds], colnames(Bnextyear)[inds],
                                 colnames(Fnextyear)[inds])
            # Data frame with uncertainties of relateive predictions
            dfrel <- cbind(BBnextyear[, inds,drop=FALSE], FFnextyear[, inds,drop=FALSE])
            colnames(dfrel) <- c(colnames(BBnextyear)[inds], colnames(FFnextyear)[inds])
            qinds <- grep('q', colnames(dfrel))
            colnames(dfrel)[qinds] <- sub('q', '/', colnames(dfrel)[qinds]) # Replace q with /
            # Set row names
            rn <- suppressWarnings(unlist(
                plyr::revalue(scenarios, replace = list("currentCatch" = 'Keep current catch',
                                                        "currentF" = 'Keep current F',
                                                        "Fmsy" = 'Fish at Fmsy',
                                                        "noF" = 'No fishing',
                                                        "redF25" = 'Reduce F 25%',
                                                        "incrF25" = 'Increase F 25%',
                                                        "msyHockeyStick" = 'MSY hockey-stick rule',
                                                        "ices" = 'ICES advice rule'))))
            rn <- paste0(paste0(seq(length(rn)),". "),rn, "")
            rownames(df) <- rn
            rownames(dfrel) <- rn
            rownames(dfabs) <- rn
            #cat('Management summary\n')
            timerangeI <- range(unlist(rep$inp$timeI))
            timerangeC <- range(rep$inp$timeC)
            lastcatchseen <- tail(rep$inp$timeC+rep$inp$dtc, 1)
            # Start printing stuff
            if (verbose){ # Time interval information
                cat(paste0('Observed interval, index:  ',
                           fd(timerangeI[1]),
                           ' - ',
                           fd(timerangeI[2]),
                           '\n'))
                cat(paste0('Observed interval, catch:  ',
                           fd(timerangeC[1]),
                           ' - ',
                           fd(lastcatchseen),
                           '\n\n'))
                cat(paste0('Fishing mortality (F) prediction: ',
                           FBtime, '\n'))
                cat(paste0('Biomass (B) prediction:           ',
                           FBtime, '\n'))
                cat(paste0('Catch (C) prediction interval:    ',
                           Ctime1,
                           ' - ',
                           Ctime2,
                           '\n\n'))
                if (rep$inp$catchunit != ''){
                    cat(paste('Catch/biomass unit:', rep$inp$catchunit, '\n\n'))
                }
                cat('Predictions\n')
            }
            print(df)
            if (include.unc){
                cat('\n95% CIs of absolute predictions\n')
                print(dfabs)
                cat('\n95% CIs of relative predictions\n')
                print(dfrel)
            }
            invisible(df)
        } else {
            cat('Warning: Could not show management results because ypred is larger than the calculated management time frame. Reduce ypred or increase inp$timepredc and run fit.spict() and manage() again.\n')
        }
    }
}


#' @name mansummary
#'
#' @title Print management summary.
#'
#' @param repin A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param ypred Show results for ypred years from manstart.
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param verbose Print more details on observed and predicted time intervals.
#'
#' @aliases sumspict.manage
#'
#' @return Data frame containing management summary.
#' @export
mansummary <- function(repin, ypred=1, include.EBinf=FALSE, include.unc=TRUE, verbose=TRUE){
    sumspict.manage(rep = repin, ypred = ypred,
                    include.EBinf=include.EBinf, include.unc=include.unc, verbose=verbose)
}


#' @name check.man.time
#' @title Checks if management time is within model time
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param maninterval man interval
#' @param maneval man eval
#' @param verbose more output
#' @return rep
check.man.time <- function(rep, maninterval = NULL, maneval = NULL, verbose = TRUE){
    repin <- rep
    inpin <- rep$inp
    if(!inherits(repin, "spictcls")) stop("not spictcls object - use fit.spict first")

    ## update man args
    if(!is.null(maninterval)) inpin$maninterval <- maninterval
    if(!is.null(maneval)) inpin$maneval <- maneval

    ## affected, but overwritten by check.inp:
    ## indpred, indCpred, ns, time, dt, seasons, seasonindex, seasonindex2, ir, isdf, ic, nc, nobsCp, dtcp, timeCpred

    ## affected:
    varNull <- c("logmcovariatein","ffacvec","fconvec", "MSYregime")
    varIniNull <- c("logF","logB","logmre","logu")

    if(max(inpin$maninterval, inpin$maneval) > max(inpin$time)){
        ## 1. correcting inp list
        ## overwrite time vectors with wrong lengths
        if(verbose) warning(c("Following variables in 'inp' are overwritten: ",
                              paste0(c(varNull,paste0("ini$",varIniNull)),collapse=", ")))
        inpout <- inpin
        for(i in varNull) inpout[i] <- NULL
        for(i in varIniNull) inpout$ini[i] <- NULL
        inpout <- check.inp(inpout, verbose = verbose)
        ## restore management
        inpout <- make.ffacvec(inpout, inpin$ffacvec[which(inpin$time == inpin$manstart)])
        inpout <- make.fconvec(inpout, inpin$fconvec[which(inpin$time == inpin$manstart)])
        ## restore prod regimes
        dtdiff <- length(inpout$MSYregime) - length(inpin$MSYregime)
        rlein <- rle(inpin$ir)
        ls <- length(rlein$lengths)
        rleout <- rlein
        rleout$lengths[ls] <- rleout$lengths[ls] + dtdiff
        inpout$ir <- inverse.rle(rleout)
        inpout$MSYregime <- as.factor(inpout$ir)
        inpout$noms <- inpin$noms
        ## 2. correcting rep list
        repout <- retape.spict(repin, inpout)
    }else{
        repout <- repin
    }
    return(repout)
}

#' @name check.catchList
#' @title Check catch list
#' @param catchList list obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided)
#' @param scenarioTitle title of scenario
#' @return Checked catchList
check.catchList <- function(catchList, sdfac = 1){
    if(!"obsC" %in% names(catchList)) stop("Element 'obsC' is missing.")
    if(!"timeC" %in% names(catchList)) stop("Element 'timeC' is missing.")
    if(!"dtc" %in% names(catchList)) stop("Element 'dtc' is missing.")

    if(length(catchList$obsC) != length(catchList$timeC)) stop("The length of the elements of the catchList have to equal.")
    if(length(catchList$obsC) != length(catchList$dtc)) stop("The length of the elements of the catchList have to equal.")

    if(!"stdevfacC" %in% names(catchList))
        catchList$stdevfacC <- rep(sdfac,length(catchList$obsC))

    return(catchList)
}


#' @name man.scenario
#' @title Define management scenario
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarioTitle title of scenario
#' @param fractiles List defining the fractiles of the 3 distributions of
#'     "catch", "bbmsy", and "ffmsy" (see details for more information). By
#'     default (0.5) median is used for all 3 quantities.
#' @param breakpointBBmsy Breakpoint in terms of \eqn{B/B_{MSY}} for the
#'     hockey-stick HCR (see details for more information). By default (0) no
#'     breakpoint is assumed.
#' @param safeguardB List defining an optional precautionary buffer by means of a
#'     biomass reference level relative to \eqn{B/B_{MSY}} ("limitB"; default =
#'     0, i.e. deactivating the PA buffer) and the risk aversion probability
#'     ("prob"; default = 0.95). For more information see details.
#' @param catchIntermediateYear Catch during assessment year (corresponding to argument
#'     \code{catch} in \code{\link{take.c}}), e.g. last year's TAC (default:
#'     \code{NULL}; see details for more information).
#' @param catchIntermediateYearSDFac Factor for the multiplication of the standard deveiation of the
#'     catch during the assessment year (\code{stdevfacC}; default = 1; see
#'     \code{\link{take.c}}).
#' @param getFit Logical; if \code{TRUE} the function returns the fitted
#'     'spictcls' object with respective HCR (\code{FALSE} by default).
#'
#' @details The combination of the arguments in the "fractiles",
#'     "breakpointB", and "safeguardB" allow defining a number of different
#'     harvest control rules (HCRs):
#'\itemize{
#' \item{Fishing at F_{MSY}: if \code{breakpointB == 0} and
#'     \code{safeguardB$limitB == 0}.}
#' \item{MSY hockey-stick rule: Fishing at F_{MSY} above a certain biomass reference
#'     level (here defined as a fraction of B_{MSY} with \code{breakpointB}).
#'     Below the reference level, fishing is reduced linearly to 0 as suggested in
#'     ICES (2017).}
#' \item{MSY (hockey-stick) rule with additional precautionary buffer: As long
#'     as the probability of the predicted biomass relative to a reference
#'     biomass level (e.g. 0.3 B_{MSY}, defined by \code{safeguardB$limitB}) is smaller or
#'     equal to a specified risk aversion probability (e.g. 95%, defined by
#'     \code{safeguardB$prob}), fishing at F_{MSY} or following the hockey-stick rule
#'     (if \code{breakpoint != 0}), otherwise reduce fishing mortality to meet
#'     specified risk aversion probability (\code{safeguardB$prob}) as introduced in
#'     ICES (2018).}
#' \item{By ICES (2019) recommended MSY hockey-stick rule with 35th percentiles:
#'     Fishing at 35th percentile of F_{MSY} above the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}} (\code{breakpointB = 0.5}) and 35th percentile of
#'     linearly reduced F_{MSY} below the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}}. TAC corresponds to 35th percentile of predicted catch.
#'     Rule is applied with \code{fractiles = list(catch=0.35, bbmsy=0.35,
#'     ffmsy=0.35)}, \code{breakpointB = 0.5}, and \code{safeguardB =
#'     list(limitB = 0, prob = 0.95)}.}}
#'
#' More information about the function arguments controlling the HCRs. The
#' arguments of the "fractiles" are:
#' \itemize{
#' \item{catch - Fractile of the predicted catch distribution. Default: 0.5.}
#' \item{bbmsy - Fractile of the \eqn{B/B_{MSY}} distribution. Default: 0.5.}
#' \item{ffmsy - Fractile of the \eqn{F/F_{MSY}} distribution. Default: 0.5.}}
#'
#' The argument "breakpointBBmsy" allows to define the MSY hockey-stick rule,
#' which reduces fishing linearly if the biomass is below specified reference
#' level as specified here relative to B_{MSY}. Theoretically, any value below 1
#' is meaningful, but ICES (2017 to 2019) recommend 50% of B_{MSY}
#' (\code{breakpointBBmsy = 0.5}).
#'
#'
#' The argument list "safeguardB" includes:
#' \itemize{
#' \item{bbmsy - Reference level for the evaluation of the predicted biomass
#'   defined as fraction of \eqn{B/B_{MSY}}. By default (\code{safeguardB$limitB == 0})
#'   the PA buffer is not used. Theoretically, any value smaller than 1 is
#'
#' meaningful, but an ICES recommended value would be 30% \code{safeguardB$limitB = 0.3}
#' (ICES, 2018).}
#' \item{prob - Risk aversion probability of the predicted biomass relative to
#'   specified reference level (\code{safeguardB$limitB}) for all rules with PA
#'   buffer (\code{safeguardB$limitB != 0}). Default: 0.95 as recommended by ICES
#'   (2018).}}
#'
#' NOTE: fractile for Fmsy is 1-f
#'
#' Dependent on the start of the management period (e.g. advice year), there
#' might be a time lag between the last observation and the start of the
#' management period. If this is the case, an assumption about the intermediate
#' time period (e.g. assessment year) has to be made. Either the fishing
#' mortality is extrapolated for the intermediate time period (\code{catchIntermediateYear
#' = NULL}; default), or the argument \code{catchIntermediateYear} can be used to set the
#' catch in that period. The argument \code{catchIntermediateYearSDFac} allows to adjust the standard
#' deviation of the catch in the intermediate time period.
#'
#' @return A list with the TAC and management relevant quantities; if
#'     \code{getFit} is \code{TRUE} the fitted object with the respective HCR is
#'     returned.
#'
#' @references
#' ICES. 2017. Report of the Workshop on the Development of the ICES
#' approach to providing MSY advice for category 3 and 4 stocks
#' (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/
#' ACOM:47. 53 pp.
#'
#' ICES. 2018. Report of the Eighth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE VIII), 8-12 October 2018, Lisbon,
#' Portugal. ICES CM 2018/ACOM:40. 172 pp.
#'
#' ICES 2019. Report of the Ninth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE IX), 30 September-4 October 2019,
#' Lisbon, Portugal.
#'
#' @export
#' @examples
#' rep <- fit.spict(pol$albacore)
#'
#' ## Fishing at Fmsy
#' get.TAC(rep)
#'
#' ## MSY hockey-stick rule
#' get.TAC(rep, breakpointB = 0.5)
#'
#' ## ICES (2019) recommended HCR
#' get.TAC(rep, fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35), breakpointB=0.5)
#'
man.scenario <- function(rep, scenarioTitle = "",
                         maninterval = NULL,
                         maneval = NULL,
                         ffac = NULL,   ## if NULL default fishing at fmsy
                         cfac = NULL,
                         csdfac = 1,
                         fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5),
                         breakpointB = 0,
                         safeguardB = list(limitB = 0, prob = 0.95),
                         catchIntermediateYear = NULL,
                         catchIntermediateYearSDFac = 1,
                         catchList = NULL,
                         getFit = TRUE,
                         verbose = TRUE,
                         dbg = 0){
    ## CHECKS
    if(!inherits(rep, "spictcls")) stop("not spictcls object - use fit.spict first")
    ## check if management time within model time
    repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = verbose)
    stopifnot(all(unlist(fractiles) <= 0.5 && unlist(fractiles) > 0))
    stopifnot(cfac >= 0)
    stopifnot(csdfac >= 0)
    stopifnot(ffac >= 0)
    stopifnot(breakpointB >= 0)
    if(is.numeric(ffac) && is.numeric(cfac))
        stop("Both 'ffac' and 'cfac' provided, please choose either or neither.")

    repout <- reppa <- repin
    inpin <- repin$inp

    ## FRACTILES
    if(!is.list(fractiles)) stop("Please provide 'fractiles' with the arguments: 'catch', 'bbmsy', and 'ffmsy'!")
    default_fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5)
    fList <- default_fractiles[which(!names(default_fractiles) %in% names(fractiles))]
    fList <- c(fList,fractiles)

    ## BIOMASS SAFEGUARD
    if(!is.list(safeguardB)) stop("Please provide 'safeguardB' with the arguments: 'limitB' and 'prob'!")
    default_safeguardB = list(limitB = 0, prob = 0.95)
    pList <- default_safeguardB[which(!names(default_safeguardB) %in% names(safeguardB))]
    pList <- c(pList,safeguardB)

    ## INTERMEDIATE YEAR
    inttime <- inpin$dtpredcinds[1] - min(inpin$indpred)
    if(inttime > 0 && !is.null(catchIntermediateYear) &&
       !is.na(catchIntermediateYear) && is.numeric(catchIntermediateYear)){
        inpt <- inpin
        dtcint <- (inpin$dtpredcinds[1] - min(inpin$indpred)) * inpin$dteuler
        if(verbose) writeLines(paste0("The intermediate time period is ",dtcint," year(s) long. The catch 'catchIntermediateYear' should be representative of that period.\n"))
        inpt$timeC <- c(inpt$timeC, inpin$time[min(inpin$indpred)])
        inpt$obsC <- c(inpt$obsC, catchIntermediateYear)
        inpt$stdevfacC <- c(inpt$stdevfacC, catchIntermediateYearSDFac)
        inpt$dtc <- c(inpt$dtc, dtcint)
        inpt <- check.inp(inpt)
        repin <- retape.spict(repin, inpin)
        inpin <- repin$inp
    }

    ## QUANTITIES
    fmanstart <- get.par('logFm', repin, exp=TRUE)[2]
    fmsy <- get.par('logFmsy', repin, exp=TRUE)[2]
    bmsy <- get.par('logBmsy', repin, exp=TRUE)[2]
    logFpFmsy <- get.par("logFpFmsynotS", repin)
    logBpBmsy <- get.par("logBpBmsy", repin)
    logFmFmsy <- get.par("logFmFmsynotS", repin)
    logBmBmsy <- get.par("logBmBmsy", repin)


    ## ADVICE RULES
    ## ---------------
    if(!is.numeric(cfac) || is.na(cfac)){
        if(!is.numeric(ffac) || is.na(ffac)){
            ## FFmsy component
            fi <- 1 - fList$ffmsy
            fmfmsyi <- exp(qnorm(fi, logFmFmsy[2], logFmFmsy[4]))
            fmfmsy5 <- exp(qnorm(0.5, logFmFmsy[2], logFmFmsy[4]))
            fred <- fmfmsy5 / fmfmsyi
            ## BBmsy component (hockey stick HCR)
            if(!is.na(breakpointB) && is.numeric(breakpointB) && breakpointB != 0){
                bmbmsyi <- 1/breakpointB * exp(qnorm(fList$bbmsy, logBmBmsy[2], logBmBmsy[4]))
                fred <- fred * min(1, bmbmsyi)
            }
            ## F reduction factor
            ffac <- (fred + 1e-8) * fmsy / fmanstart
            ## PA component
            if(!is.na(pList$bbmsy) && is.numeric(pList$bbmsy) && pList$bbmsy != 0){
                inppa <- make.ffacvec(inpin, ffac)
                ## TODO: use retape
                reppa$obj$env$data$ffacvec <- inppa$ffacvec
                reppa$obj$env$data$reportmode <- 1
                reppa$obj$retape()
                reppa$obj$fn(repin$opt$par)
                sdr <- try(sdreport(reppa$obj), silent=TRUE)
                if(is(sdr,"try-error")) stop("Model variances could not be estimated with the PA.")


                logBpBmsyPA <- get.par("logBpBmsy", sdr)  ## CHECK: use of sdr after retape
                probi <- 1 - pList$prob
                bpbmsyiPA <- exp(qnorm(probi, logBpBmsyPA[2], logBpBmsyPA[4]))
                if((bpbmsyiPA - pList$bbmsy) < -1e-3){
                    ffac <- try(get.ffac(reppa, frac_relstate=pList$bbmsy,
                                         problevel=pList$prob,
                                         relstate="logBpBmsy",
                                         reportmode = 1), silent=TRUE)
                    if(is(ffac,"try-error")) stop("F multiplication factor could not be estimated with the PA.")
                }
            }
        }
        inpt <- make.ffacvec(inpin, ffac)
    }else{
        ## Fishing with provided catch
        inpt <- inpin
##        browser()
        if(is.null(catchList)){
            manint <- inpin$maninterval
            manperiod <- max(manint) - min(manint)
            mindtc <- min(inpin$dtc)
            if(manperiod < min(inpin$dtc))
                stop("Management interval is shorter than the smallest resolution of the catch observation - Use 'catchList' to specify catch during management interval  or change management period to correspond a multiple of the catch observation intervals.")
            if(manperiod %% mindtc != 0)
                stop("Catch during management interval cannot be aggregated from catch observations - Use 'catchList' to specify catch during the management period or change management period to correspond a multiple of the catch observation intervals.")
            ## TODO: make errors warnings and find meaningful assumptions if conditions are not met

            tmpTime <- inpin$timeCpred
            lastXc <- tail(inpin$obsC,1/mindtc)
            lastXdtc <- tail(inpin$dtc,1/mindtc)
            maninds <- which(tmpTime >= min(inpin$maninterval))
            ##
            cumsumdtc <- cumsum(rev(inpin$dtc))
            if(manperiod %in% cumsumdtc){
                indc4manperiod <- which(cumsumdtc == manperiod)
                manC <- sum(rev(inpin$obsC)[1:indc4manperiod])
            }else stop("Catch during management interval cannot be aggregated from catch observations - Use 'catchList' to specify catch during the management period or change management period to correspond a multiple of the catch observation intervals.")
            inpt$timeC <- c(inpt$timeC, tmpTime[maninds])
            inpt$obsC <- c(inpt$obsC, rep(manC * cfac, length(maninds)))
            inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(maninds)))
            inpt$dtc <- c(inpt$dtc, rep(inpt$dtpredc, length(maninds)))
        } else {
            check.catchList(catchList)
            inpt$timeC <- c(inpt$timeC, catchList$timeC)
            inpt$obsC <- c(inpt$obsC, catchList$obsC)
            if(is.null(catchList$stdevfacC)){
                inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(catchList$timeC)))
            }else{
                inpt$stdevfacC <- c(inpt$stdevfacC, catchList$stdevfacC)
            }
            inpt$dtc <- c(inpt$dtc, catchList$dtc)
        }
        inpt <- check.inp(inpt, verbose = FALSE)
    }

    if(getFit){
        ## retape spict
        repout <- retape.spict(repin, inpt)
        ## check if man already in repin
        if(!"man" %in% names(repin)){
            repout$man <- list()
            # Create an baseline F trajectory with constant F and store
            repout <- man.scenario(repout, scenarioTitle = "manbase", ffac = 1.0)
            repout$man[[1]] <- repout
            if(scenarioTitle == "") scenarioTitle <- "customScenario_1"
            names(repout$man)[1] <- scenarioTitle
            return(repout)
        }else{
            if(scenarioTitle == "manbase"){
                repout$manbase <- repout
            }else{
                if(scenarioTitle == ""){  ## set customScenario name with counter
                    custcount <- length(which("customScenario" %in% unlist(strsplit(names(repin$man),"_")))) + 1
                    scenarioTitle <- paste0("customScenario_", custcount)
                }
                nman <- length(repin$man) + 1
                repout$man[[nman]] <- repout
                names(repout$man)[nman] <- scenarioTitle
            }
            return(repout)
        }
    }else{
        ## return tac only
        tac <- try(calc.tac(rep=repin, ffac=ffac, fractileCatch=fList$catch), silent=TRUE)
        if(is(tac,"try-error")) stop("TAC could not be estimated.")
        return(tac)
    }
}


#' @name probdev
#' @title Estimate deviation between targeted and realised probability of
#'     overfishing
#' @param ffac Factor to multiply current F by
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param relstate Relative state for estimation of probability of overfishing
#'     (one of the relative states returned by \code{\link{fit.spict}}; default
#'     = "logBpBmsy").
#' @param frac_relstate Fraction of relative state (\code{relstate}; default =
#'     1)
#' @param problevel Probability level of risk aversion (default = 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default = 1).
#' @param getFrac logical; return realised fraction of relative state (default =
#'     FALSE).
#' @param verbose logical; print realised fraction of relative state, fishing
#'     mortality factor, and deviation (default = FALSE).
#' @return Returns deviation between targeted and realised probability of being
#'     above certain biomass threshold under set fishing mortality
probdev <- function(ffac, rep, relstate = "logBpBmsy", frac_relstate = 1,
                    problevel = 0.95, reportmode = 1, getFrac = FALSE,
                    verbose = FALSE){
    ## get F factor
    inpt <- make.ffacvec(rep$inp, ffac)
    rep$obj$env$data$ffacvec <- inpt$ffacvec
    rep$obj$env$data$reportmode <- reportmode
    rep$obj$retape()
    rep$obj$fn(rep$opt$par)
    sdr <- sdreport(rep$obj)
    rstate <- get.par(relstate,sdr)
    ll <- qnorm(1 - problevel, rstate[,2], rstate[,4])
    dev <- (exp(ll) - frac_relstate)^2
    if(verbose)  cat("exp(ll): ",exp(ll),"ffac: ",ffac," dev: ",dev,"\n")
    if(getFrac) dev <- exp(ll)
    dev
}


#' @name get.ffac
#' @title Estimate fishing mortality factor minimising risk of overfishing
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param relstate Relative state as returned by \code{\link{fit.spict}}
#'     (default = "logBpBmsy").
#' @param frac_relstate Fraction of relative state (\code{relstate}; default =
#'     1)
#' @param problevel Probability level of risk aversion (default = 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default = 1).
#' @return Optimised Fishing mortality for P(Bp<Blim)
get.ffac <- function(rep, relstate = "logBpBmsy", frac_relstate=1,
                     problevel=0.95, reportmode = 1){
    ## see if is possible even with zero F
    frac_ffac0 <- probdev(ffac=1e-6, rep=rep, getFrac=TRUE, problevel=problevel,
                    frac_relstate=frac_relstate, relstate = relstate,
                    reportmode=reportmode, verbose=FALSE)
    if(!is.finite(frac_ffac0) || (frac_ffac0 - frac_relstate) < -1e-3){
        ## cat("Not possible even with zero F\n")
        return(1e-6)
    }
    offac <- optimize(probdev, c(1e-6,5), tol=1e-2, rep=rep,
                      frac_relstate=frac_relstate, problevel=problevel,
                      relstate=relstate, reportmode=reportmode,
                      verbose=FALSE)
    offac$minimum
}


#' @name calc.tac
#' @title Calculate Total Allowable Catch (TAC)
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param ffac Factor to multiply current F by
#' @param fractileCatch The fractile of the catch distribution to be used for
#'     setting the TAC. Default (0.5) corresponds to the median.
#' @param exp Should tac be reported on natural scale? (default = TRUE)
#' @return Total Allowable Catch (TAC)
#' @export
calc.tac <- function(rep, ffac = NULL, fractileCatch = 0.5, exp = TRUE){
    if(!inherits(rep, "spictcls")) stop("not spictcls object - use fit.spict first")
    if(!is.null(ffac) && is.numeric(ffac)){
        inpt <- make.ffacvec(rep$inp, ffac)

        rep <- retape(repin, inpt)

        rep$obj$env$data$ffacvec <- inpt$ffacvec
        rep$obj$env$data$reportmode <- 2
        rep$obj$retape()
        rep$obj$fn(rep$opt$par)
        sdr <- sdreport(rep$obj)
    }else{
        sdr <- rep
    }


    if(fractileCatch == 0.5){
        tac <- rep$obj$report(rep$obj$env$last.par.best)$Cp
    }else{
        logCp <- get.par('logCp', sdr)
        tac <- exp(qnorm(fractileCatch, logCp[2], logCp[4]))
    }
    if(!exp) tac <- log(tac)
    return(tac)
}


#' @name man.select
#' @title Select management scenarios
#' @param rep Result list from manage().
#' @param scenarios scenarios to select in preferred order
#'
#' @return rep wit selected management scenarios
#' @export
man.select <- function(rep, scenarios = "all"){
    if(!inherits(rep, "spictcls")) stop("not spictcls object - use fit.spict first")
    if(!"man" %in% names(rep)) stop("Apply manage() first.")

    repout <- rep

    if(all(is.numeric(scenarios))){
        ind <- scenarios
    }else if(scenarios == "all"){
        ind <- seq(length(rep$man))
    }else{
        ind <- which(names(rep$man) %in% scenarios)
    }
    repout$man <- rep$man[ind]
    attr(repout$man, "scenarios") <- 1:length(repout$man)

    return(repout)
}


#' @name man.tac
#' @title Get the TAC for the management scenarios
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param fractileCatch
#' @param exp
#'
#' @return rep wit selected management scenarios
#' @export
man.tac <- function(rep, fractileCatch = 0.5, exp = TRUE){
    if(!inherits(rep, "spictcls")) stop("not spictcls object - use fit.spict first")
    if(!"man" %in% names(rep)) stop("Apply manage() or man.scenario() first.")

    ## function(x) x$obj$report(x$obj$env$last.par.best)$Cp
    tacs <- lapply(rep$man, calc.tac, ffac = NULL, fractileCatch = fractileCatch, exp = exp)

    return(tacs)
}


#' @name manbase.select
#' @title Change the management base scenario
#' @param rep A result report as generated by running \code{manage} or \code{man.scenario}.
#' @param scenario New manbase scenario
#'
#' @return rep wit selected management scenario as the manbase scenario
#' @export
manbase.select <- function(rep, scenario){
    if(!inherits(rep, "spictcls")) stop("not spictcls object - use fit.spict first")
    if(!"man" %in% names(rep)) stop("Apply manage() or man.scenario() first.")
    if(!scenario %in% names(rep$man)) stop(paste0("Scenario ",scenario, "not included in 'rep$man'."))

    repin <- rep
    repout <- repin$man[[scenario]]
    repout$manbase <-repin$man[[scenario]]
    repout$man <- repin$man

    return(repout)
}
